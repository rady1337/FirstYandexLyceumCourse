<head><link rel="stylesheet" href="https://yastatic.net/s3/lyceum/frontend/static/40.0-rc-39c44ae1/desktop-ru/client.css"><link rel="stylesheet" href="https://yastatic.net/s3/lyceum/frontend/static/40.0-rc-39c44ae1/desktop-ru/material.css"><link rel="stylesheet" type="text/css" href="https://yastatic.net/s3/lyceum/frontend/static/40.0-rc-39c44ae1/desktop-ru/code-mirror-editor.css"><link rel="stylesheet" href="https://yastatic.net/s3/lyceum/frontend/static/40.0-rc-39c44ae1/desktop-ru/vendors.css"></head><h1>Строки. Срезы</h1><section class="material__plan"><nav><ol><li><a class="material__link" href="#1">Работа со&nbsp;строками (повторение)</a></li><li><a class="material__link" href="#2">Срезы строк</a></li></ol></nav></section><section class="material__annotation"><h2>Аннотация</h2><p>На&nbsp;этом занятии мы&nbsp;продолжим отрабатывать навыки работы со&nbsp;строкой и&nbsp;познакомимся с&nbsp;новым методом извлечения подстроки&nbsp;&mdash; срезами.</p></section><section class="material__chapter"><h2 id="1">Работа со&nbsp;строками (повторение)</h2><p>Рассмотрим еще одну задачу. Билет называют счастливым по-питерски, если сумма цифр его номера, стоящих на&nbsp;четных местах, равна сумме цифр, стоящих на&nbsp;нечетных местах. Нам необходимо написать программу, которая определяет, является&nbsp;ли билет счастливым по-питерски.</p><div class="material__content-positioner"><img class="material__illustration" src="https://yastatic.net/s3/lyceum/content/images/first-year/lesson-11/11.svg" width="480" height="auto" /></div><p>Если рассматривать номер билета как строку из&nbsp;цифр, задача сводится к&nbsp;подсчету суммы цифр, стоящих на&nbsp;позициях 0, 2, 4..., и&nbsp;суммы цифр, стоящих на&nbsp;позициях 1, 3, 5... Чтобы перебрать элементы, мы&nbsp;можем воспользоваться конструкцией <code>for i&nbsp;in&nbsp;range(...)</code>, указав шаг 2. Тогда соответствующий фрагмент программы может выглядеть следующим образом:</p><pre><code class="language-python">number = input()odd = even = 0for i in range(0, len(number), 2):    odd += int(number[i])for i in range(1, len(number), 2):    even += int(number[i])if odd == even:    print('Счастливый по-питерски!')</code></pre><p>Подумайте, как можно решить данную задачу за&nbsp;один цикл.</p></section><section class="material__chapter"><h2 id="2">Срезы строк</h2><p>На&nbsp;примере разобранной задачи мы&nbsp;увидели, что перебор элементов строки с&nbsp;помощью конструкции <code>for i&nbsp;in&nbsp;range(...)</code> является достаточно гибким: можно перебрать не&nbsp;все индексы, можно идти с&nbsp;шагом, скажем, 2&nbsp;или даже &minus;1, то&nbsp;есть в&nbsp;обратном порядке. Но&nbsp;существует способ без всякого цикла преобразовать строку нужным образом: взять отдельный ее&nbsp;кусок, символы с&nbsp;нечетными номерами и&nbsp;т.&nbsp;д. Этот способ&nbsp;&mdash; <strong>срез (slice)</strong>.</p><section class="material__note"><p class="material__note-heading"><strong>Срез строки</strong></p><p>В&nbsp;самом простом варианте срез строки&nbsp;&mdash; ее&nbsp;кусок от&nbsp;одного индекса включительно и&nbsp;до&nbsp;другого не&nbsp;включительно (как для <var>range</var>). То&nbsp;есть это новая, более короткая строка.</p><p>Срез записывается с&nbsp;помощью квадратных скобок, в&nbsp;которых указывается начальный и&nbsp;конечный индекс, разделенные двоеточием.</p></section><pre><code class="language-python">text = 'Hello, world!'print(text[0:5])print(text[7:12])</code></pre><p>Если не&nbsp;указан <strong>начальный индекс</strong>, срез берется от&nbsp;начала (от&nbsp;0). Если не&nbsp;указан <strong>конечный индекс</strong>, срез берется до&nbsp;конца строки. Попробуйте предположить, что будет выведено на&nbsp;экран, если в&nbsp;предыдущей программе записать срезы следующим образом:</p><pre><code class="language-python">text = 'Hello, world!'print(text[:5])print(text[7:])</code></pre><p><strong>Разрешены отрицательные индексы</strong> для отсчета с&nbsp;конца списка. В&nbsp;следующем примере из&nbsp;строки, содержащей фамилию, имя и&nbsp;отчество, будет извлекаться фамилия.</p><pre><code class="language-python">full_name = 'Иванов И. И.'surname = full_name[:-6]</code></pre><p>Как и&nbsp;для <var>range</var>, в&nbsp;параметры среза можно добавить третье число&nbsp;&mdash; <strong>шаг обхода</strong>. Этот параметр не&nbsp;является обязательным и&nbsp;записывается через второе двоеточие. Вот как может выглядеть программа &laquo;Счастливый билет&raquo;, если решать ее&nbsp;с&nbsp;помощью срезов:</p><pre><code class="language-python">number = input()odd = even = 0# срез будет от начала строки до конца с шагом два: 0, 2, 4,... for n in number[::2]:      odd += int(n)# срез от второго элемента строки до конца с шагом два: 1, 3, 5,...for n in number[1::2]:     even += int(n)if odd == even:    print('Счастливый по-питерски!')</code></pre><p>Интересное отличие среза от&nbsp;обращения по&nbsp;индексу к&nbsp;отдельному элементу состоит в&nbsp;том, что мы&nbsp;не&nbsp;получим ошибку при указании границ среза за&nbsp;пределами строки. В&nbsp;срез в&nbsp;таком случае попадут только те&nbsp;элементы, которые находятся по&nbsp;валидным индексам среза:</p><pre><code class="language-python">a = 'Python'print(a[2:10000]) # thonprint(a[999:]) # пустая строка</code></pre><p><strong>Шаг может быть и&nbsp;отрицательным</strong>&nbsp;&mdash; для прохода по&nbsp;строке в&nbsp;обратном порядке. Если в&nbsp;этом случае не&nbsp;указать начальный и&nbsp;конечный индекс среза, ими станут последний и&nbsp;первый индексы строки соответственно (а&nbsp;не&nbsp;наоборот, как при положительном шаге):</p><pre><code class="language-python">text = 'СЕЛ В ОЗЕРЕ БЕРЕЗОВ ЛЕС'text_reversed = text[::-1]print(text == text_reversed)</code></pre><p>Итак, с&nbsp;помощью квадратных скобок можно получить доступ как к&nbsp;одному символу строки, так и&nbsp;к&nbsp;некоторой последовательности символов, причем совсем необязательно идущих подряд!</p></section>